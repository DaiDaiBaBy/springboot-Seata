# springboot-Seata
SpringBoot分布式事务整合Seata：
  在springboot单体项目中，如果使用了多数据源，我们就需要考虑多个数据源的数据一致性，即产生了分布式事务的问题，我们采用了Seata的AT事务模式来解决   
  参考来源于文章：https://blog.csdn.net/qq_32691791/article/details/112727500


系统同时对Mysql更新数据、 插入或者删除数据操作
Seata 是什么?
Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案


全局锁与本地锁的互相使用及限制：
事务的每一个操作的记录都拥有自己的本地锁和全局锁，  控制权限 全局锁 > 本地锁  
    （开启本地事务，拿到本地锁，  本地事务的提交，则会尝试去拿到全局锁，获取到全局锁才会本地事务的提交）=====》 避免了 脏写 的问题

事务的隔离分布：
|事务隔离级别|脏读|不可重复读|幻读|
读未提交(read—uncommitted)  是   是   是 
不可重复读(read-committed)   否   是   是
可重复读(repeatable-read)   否   否   是
串行化(serializable)   否   否   否

mysql默认的事务隔离级别为repeatable-read

事务的并发问题：
脏读： 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据
不可重复读：  事务A多次读取同一条数据，事务B在事务A多次读取过程中，对数据做了更新并提交，导致事务A多次读取同一数据时。结果不一致
幻读： 系统管理员A 将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，
    当系统管理员A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，即为幻读
小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

补充：
　　1、事务隔离级别为读提交时，写数据只会锁住相应的行
　　2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；
        如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读
　　3、事务隔离级别为串行化时，读写数据都会锁住整张表
　　4、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大


使用Mybatis逆向工程generator自动生成Mybatis配置的mysql实体类、映射mapper、以及mapper.xml文件
(配置完generator.xml文件后，去运行generator里面的主函数main自动生成即可)


配置seata：
    去到 http://seata.io/zh-cn/docs/overview/what-is-seata.html 下载seata二进制压缩包
    然后本地解压后进入/bin路径下cmd执行 seata-server.bat , 出现 8091端口即为成功启动，然后启动springboot项目  
    

